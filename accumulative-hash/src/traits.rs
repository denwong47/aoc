//! Trait definitions for accumulative hash types.
//!
//! These traits define the properties required for a type to be used
//! as the underlying type for an accumulative hash.

use num_traits::{WrappingAdd, WrappingMul, WrappingSub, Zero};
use std::ops::{BitXor, Shr};

#[cfg(feature = "atomic")]
use std::sync::atomic::{self, Ordering};

/// Trait defining the properties required for an accumulative hash type.
///
/// Only implemented for primitive unsigned integer types: [`u8`], [`u16`], [`u32`],
/// [`u64`], and [`u128`], and the usage of anything below [`u64`] is not recommended
/// for production use due to the high likelihood of collisions.
pub trait IsAccumulativeHashType:
    Sized
    + Copy
    + PartialEq
    + Eq
    + BitXor<Output = Self>
    + Shr<Output = Self>
    + WrappingAdd
    + WrappingSub
    + WrappingMul
    + Zero
{
    const SEED: Self;
    const SHIFT_CONSTANTS: [Self; 3];
    const MULTIPLIER_CONSTANTS: [Self; 2];
}

#[cfg(feature = "atomic")]
/// Trait defining the properties required for an atomic accumulative hash type.
///
/// This is a sub-trait of [`IsAccumulativeHashType`] that adds an associated
/// type representing the underlying non-atomic type.
pub trait IsAtomicAccumulativeHashType: Sync + Send
where
    Self: From<Self::UnderlyingType>,
{
    type UnderlyingType: IsAccumulativeHashType;

    /// Convert the atomic type to its underlying type.
    fn to_underlying(&self, order: Ordering) -> Self::UnderlyingType;

    /// Stores a value into the atomic integer if the current value is the same as the
    /// current value.
    ///
    /// The return value is a result indicating whether the new value was written and
    /// containing the previous value. On success this value is guaranteed to be equal
    /// to current.
    ///
    /// [`compare_exchange`] takes two [`Ordering`] arguments to describe the memory
    /// ordering of this operation. ``success`` describes the required ordering for the
    /// read-modify-write operation that takes place if the comparison with current
    /// succeeds. ``failure`` describes the required ordering for the load operation
    /// that takes place when the comparison fails. Using [`Ordering::Acquire`] as
    /// success ordering makes the store part of this operation [`Ordering::Relaxed`],
    /// and using [`Ordering::Release`] makes the successful load [`Ordering::Relaxed`].
    /// The ``failure`` ordering can only be [`Ordering::SeqCst`], [`Ordering::Acquire`]
    /// or [`Ordering::Relaxed`].
    /// 
    /// [`compare_exchange`]: `Self::compare_exchange`
    fn compare_exchange(
        &self,
        current: Self::UnderlyingType,
        new: Self::UnderlyingType,
        success: Ordering,
        failure: Ordering,
    ) -> Result<Self::UnderlyingType, Self::UnderlyingType>;
}

/// Implementation of [`IsAccumulativeHashType`] for [`u8`].
///
/// This implementation uses constants generated by the script
/// ``scripts/generate_constants.py --bits 8```.
impl IsAccumulativeHashType for u8 {
    const SEED: Self = 0x9E;
    const SHIFT_CONSTANTS: [Self; 3] = [1, 2, 3];
    const MULTIPLIER_CONSTANTS: [Self; 2] = [0xBB, 0xA5];
}

/// Implementation of [`IsAccumulativeHashType`] for [`u16`].
///
/// This implementation uses constants generated by the script
/// ``scripts/generate_constants.py --bits 16```.
impl IsAccumulativeHashType for u16 {
    const SEED: Self = 0x9E37;
    const SHIFT_CONSTANTS: [Self; 3] = [5, 6, 3];
    const MULTIPLIER_CONSTANTS: [Self; 2] = [0x6A09, 0xBB67];
}

/// Implementation of [`IsAccumulativeHashType`] for [`u32`].
///
/// This implementation uses constants generated by the script
/// ``scripts/generate_constants.py --bits 32```.
impl IsAccumulativeHashType for u32 {
    const SEED: Self = 0x9E3779B9;
    const SHIFT_CONSTANTS: [Self; 3] = [13, 14, 11];
    const MULTIPLIER_CONSTANTS: [Self; 2] = [0x6A09E667, 0xBB67AE85];
}

/// Implementation of [`IsAccumulativeHashType`] for [`u64`].
///
/// This implementation uses constants generated by the script
/// ``scripts/generate_constants.py --bits 64 --output rust```.
impl IsAccumulativeHashType for u64 {
    const SEED: Self = 0x9E3779B97F4A7C15;
    const SHIFT_CONSTANTS: [Self; 3] = [29, 30, 27];
    const MULTIPLIER_CONSTANTS: [Self; 2] = [0xBB67AE8584CAA73B, 0x3C6EF372FE94F82B];
}

/// Implementation of [`IsAccumulativeHashType`] for [`u128`].
///
/// This implementation uses constants generated by the script
/// ``scripts/generate_constants.py --bits 128 --output rust```.
impl IsAccumulativeHashType for u128 {
    const SEED: Self = 0x9E3779B97F4A7C15F39CC0605CEDC834;
    const SHIFT_CONSTANTS: [Self; 3] = [61, 62, 59];
    const MULTIPLIER_CONSTANTS: [Self; 2] = [
        0xBB67AE8584CAA73B25742D7078B83B89,
        0xA54FF53A5F1D36F1CEA7E61FC37A20D5,
    ];
}

#[cfg(target_pointer_width = "64")]
/// Implementation of [`IsAccumulativeHashType`] for [`usize`].
///
/// This implementation uses constants generated by the script
/// ``scripts/generate_constants.py --bits 64 --output rust```.
impl IsAccumulativeHashType for usize {
    const SEED: Self = <u64 as IsAccumulativeHashType>::SEED as Self;
    const SHIFT_CONSTANTS: [Self; 3] = [
        <u64 as IsAccumulativeHashType>::SHIFT_CONSTANTS[0] as Self,
        <u64 as IsAccumulativeHashType>::SHIFT_CONSTANTS[1] as Self,
        <u64 as IsAccumulativeHashType>::SHIFT_CONSTANTS[2] as Self,
    ];
    const MULTIPLIER_CONSTANTS: [Self; 2] = [
        <u64 as IsAccumulativeHashType>::MULTIPLIER_CONSTANTS[0] as Self,
        <u64 as IsAccumulativeHashType>::MULTIPLIER_CONSTANTS[1] as Self,
    ];
}

#[cfg(target_pointer_width = "32")]
/// Implementation of [`IsAccumulativeHashType`] for [`usize`].
/// This implementation uses constants generated by the script
/// ``scripts/generate_constants.py --bits 32 --output rust```.
impl IsAccumulativeHashType for usize {
    const SEED: Self = <u32 as IsAccumulativeHashType>::SEED as Self;
    const SHIFT_CONSTANTS: [Self; 3] = [
        <u32 as IsAccumulativeHashType>::SHIFT_CONSTANTS[0] as Self,
        <u32 as IsAccumulativeHashType>::SHIFT_CONSTANTS[1] as Self,
        <u32 as IsAccumulativeHashType>::SHIFT_CONSTANTS[2] as Self,
    ];
    const MULTIPLIER_CONSTANTS: [Self; 2] = [
        <u32 as IsAccumulativeHashType>::MULTIPLIER_CONSTANTS[0] as Self,
        <u32 as IsAccumulativeHashType>::MULTIPLIER_CONSTANTS[1] as Self,
    ];
}

// #[cfg(target_has_atomic_load_store = "8")]
#[cfg(feature = "atomic")]
/// Implementation of [`IsAtomicAccumulativeHashType`] for [`std::sync::atomic::AtomicU8`].
/// The underlying type is [`u8`].
impl IsAtomicAccumulativeHashType for atomic::AtomicU8 {
    type UnderlyingType = u8;

    fn to_underlying(&self, order: Ordering) -> Self::UnderlyingType {
        self.load(order)
    }

    fn compare_exchange(
        &self,
        current: Self::UnderlyingType,
        new: Self::UnderlyingType,
        success: Ordering,
        failure: Ordering,
    ) -> Result<Self::UnderlyingType, Self::UnderlyingType> {
        self.compare_exchange(current, new, success, failure)
    }
}

// #[cfg(target_has_atomic_load_store = "16")]
#[cfg(feature = "atomic")]
/// Implementation of [`IsAtomicAccumulativeHashType`] for [`std::sync::atomic::AtomicU16`].
/// The underlying type is [`u16`].
impl IsAtomicAccumulativeHashType for atomic::AtomicU16 {
    type UnderlyingType = u16;

    fn to_underlying(&self, order: Ordering) -> Self::UnderlyingType {
        self.load(order)
    }

    fn compare_exchange(
        &self,
        current: Self::UnderlyingType,
        new: Self::UnderlyingType,
        success: Ordering,
        failure: Ordering,
    ) -> Result<Self::UnderlyingType, Self::UnderlyingType> {
        self.compare_exchange(current, new, success, failure)
    }
}

// #[cfg(target_has_atomic_load_store = "32")]
#[cfg(feature = "atomic")]
/// Implementation of [`IsAtomicAccumulativeHashType`] for [`std::sync::atomic::AtomicU32`].
/// The underlying type is [`u32`].
impl IsAtomicAccumulativeHashType for atomic::AtomicU32 {
    type UnderlyingType = u32;

    fn to_underlying(&self, order: Ordering) -> Self::UnderlyingType {
        self.load(order)
    }

    fn compare_exchange(
        &self,
        current: Self::UnderlyingType,
        new: Self::UnderlyingType,
        success: Ordering,
        failure: Ordering,
    ) -> Result<Self::UnderlyingType, Self::UnderlyingType> {
        self.compare_exchange(current, new, success, failure)
    }
}

// #[cfg(target_has_atomic_load_store = "64")]
#[cfg(feature = "atomic")]
/// Implementation of [`IsAtomicAccumulativeHashType`] for [`std::sync::atomic::AtomicU64`].
/// The underlying type is [`u64`].
impl IsAtomicAccumulativeHashType for atomic::AtomicU64 {
    type UnderlyingType = u64;

    fn to_underlying(&self, order: Ordering) -> Self::UnderlyingType {
        self.load(order)
    }

    fn compare_exchange(
        &self,
        current: Self::UnderlyingType,
        new: Self::UnderlyingType,
        success: Ordering,
        failure: Ordering,
    ) -> Result<Self::UnderlyingType, Self::UnderlyingType> {
        self.compare_exchange(current, new, success, failure)
    }
}

// #[cfg(any(target_has_atomic_load_store = "64", target_has_atomic_load_store = "32"))]
#[cfg(any(target_pointer_width = "64", target_pointer_width = "32"))]
#[cfg(feature = "atomic")]
/// Implementation of [`IsAtomicAccumulativeHashType`] for [`std::sync::atomic::AtomicUsize`].
/// The underlying type is [`usize`].
impl IsAtomicAccumulativeHashType for atomic::AtomicUsize {
    type UnderlyingType = usize;

    fn to_underlying(&self, order: Ordering) -> Self::UnderlyingType {
        self.load(order)
    }

    fn compare_exchange(
        &self,
        current: Self::UnderlyingType,
        new: Self::UnderlyingType,
        success: Ordering,
        failure: Ordering,
    ) -> Result<Self::UnderlyingType, Self::UnderlyingType> {
        self.compare_exchange(current, new, success, failure)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    macro_rules! create_test {
        ($name:ident::<$typ:ty>()) => {
            #[test]
            fn $name() {
                let _seed: $typ = <$typ as IsAccumulativeHashType>::SEED;
                let _shifts = <$typ as IsAccumulativeHashType>::SHIFT_CONSTANTS;
                let _multipliers = <$typ as IsAccumulativeHashType>::MULTIPLIER_CONSTANTS;

                assert!(_shifts.len() == _multipliers.len() + 1);
                for shift in _shifts.iter() {
                    assert!(*shift > 0, "Shift constants must be greater than 0");
                    assert!(
                        *shift < (<$typ>::BITS as $typ / 2),
                        "Shift constants must be less than half the bit size of the type"
                    );
                }

                for multiplier in _multipliers.iter() {
                    assert!(
                        *multiplier % 2 == 1,
                        "Multiplier constants must be odd numbers"
                    );
                }
            }
        };
    }

    create_test!(test_u8::<u8>());
    create_test!(test_u16::<u16>());
    create_test!(test_u32::<u32>());
    create_test!(test_u64::<u64>());
}
